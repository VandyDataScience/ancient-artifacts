---
title: "20-data-exploration"
output: html_notebook
---

The purpose of this notebook is for EDA.

```{r}
#Helpful mports
library(DataExplorer)
library(tidyverse)
library(vroom)
library(janitor)
library(batman)
library(ggplot2)


```

```{r}
#Store file name for access - test with single file name with csv files
lithic_file <- "./LithicExperimentalData.csv"
lithic_file
soil_file <- "./ArchaeologicalSoilData.csv"
lithic <- vroom(lithic_file, delim = ",")
```

Here we will attempt to create a templatized data frame for automated reading
```{r}
#set default column types
column_data_types <- c( Id = "c", .default = "n", Filter0 = "c", Filter1 = "c", Filter2 = "c", Filter3 = "c"
                        , Filter4 = "c", Filter5 = "c", Filter6 = "c")
#read in lithic_file, clean names, add file_id column
templatedLithic <- vroom(lithic_file, delim = ",", .name_repair = ~ janitor::make_clean_names(., case = "snake"),
                         col_types = column_data_types, id = "file_id")   
#convert img_id to char
templatedLithic$img_id <- as.character(templatedLithic$img_id)
#remove bad data in row 1
templatedLithic <- templatedLithic [-c(1), ]
#convert filters to pure logicals
templatedLithic$filter0 <- batman::to_logical(templatedLithic$filter0, custom_false = c("reject"))
templatedLithic$filter1 <- batman::to_logical(templatedLithic$filter1, custom_false = c("reject"))
templatedLithic$filter2 <- batman::to_logical(templatedLithic$filter2, custom_false = c("reject"))
templatedLithic$filter3 <- batman::to_logical(templatedLithic$filter3, custom_false = c("reject"))
templatedLithic$filter4 <- batman::to_logical(templatedLithic$filter4, custom_false = c("reject"))
templatedLithic$filter5 <- batman::to_logical(templatedLithic$filter5, custom_false = c("reject"))
templatedLithic$filter6 <- batman::to_logical(templatedLithic$filter6, custom_false = c("reject"))
templatedLithic
```

```{r}
#set default column types
column_data_types <- c( Id = "c", .default = "n", Filter0 = "c", Filter1 = "c", Filter2 = "c", Filter3 = "c"
                        , Filter4 = "c", Filter5 = "c", Filter6 = "c")
#read in lithic_file, clean names, add file_id column
templatedSoil <- vroom(soil_file, delim = ",", .name_repair = ~ janitor::make_clean_names(., case = "snake"),
                         col_types = column_data_types, id = "file_id")   
#convert img_id to char
templatedSoil$img_id <- as.character(templatedSoil$img_id)
#remove bad data in row 1
templatedLithic <- templatedLithic [-c(1), ]
#convert filters to pure logicals
templatedSoil$filter0 <- batman::to_logical(templatedSoil$filter0, custom_false = c("reject"))
templatedSoil$filter1 <- batman::to_logical(templatedSoil$filter1, custom_false = c("reject"))
templatedSoil$filter2 <- batman::to_logical(templatedSoil$filter2, custom_false = c("reject"))
templatedSoil$filter3 <- batman::to_logical(templatedSoil$filter3, custom_false = c("reject"))
templatedSoil$filter4 <- batman::to_logical(templatedSoil$filter4, custom_false = c("reject"))
templatedSoil$filter5 <- batman::to_logical(templatedSoil$filter5, custom_false = c("reject"))
templatedSoil$filter6 <- batman::to_logical(templatedSoil$filter6, custom_false = c("reject"))
templatedSoil
```


Let's begin creating violin plots
```{r}
total <- rbind(templatedLithic, templatedSoil)


lwviolin <- ggplot(total, aes(x= file_id, y=l_w_ratio)) + 
  geom_violin()
lwviolin + stat_summary(fun.data="mean_sdl", mult=1, 
                 geom="crossbar", width=0.2 )
lwviolin +  theme_classic()
lwviolin + scale_fill_brewer(palette="Blues") + theme_classic()

lwviolin

circleviolin <- ggplot(total, aes(x= file_id, y=circularity)) + 
  geom_violin()
circleviolin

transpviolin <- ggplot(total, aes(x= file_id, y=transparency)) + 
  geom_violin()
transpviolin

angulviolin <- ggplot(total, aes(x= file_id, y=angularity)) + 
  geom_violin()
angulviolin

solidity_violin <- ggplot(total, aes(x= file_id, y=solidity)) + 
  geom_violin()
solidity_violin
```

subplotting to get it together

facet grid to help facilitate
grid extra 

run that notebook
run my notebook

execute perl from kniter
snatches code from markdown
source it 

store in a .r data file
data loaded back in - frowned upon 
