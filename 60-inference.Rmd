---
title: "60_inference"
output: html_notebook
---

Provide a framework for predicting across multiple models


#Load models and relevant prediction data (from Box - this information will probably be stored as a .RData object)

#Load relevant prediction data from Box

# Validate prediction 
```{r validate prediction dataframe }

validate_predictions <- function(pred_data) {
  
  # Angularity: 0 (perfect circle)-180 (many sharp edges)
assert(pred_data, within_bounds(0,180), angularity, 
       description = "Values must be within 0-180 range.")

# Circularity: 0-1 (perfect circle)
assert(pred_data, within_bounds(0,1), circularity,
       description = "Values must be within 0-1 range.")

# Solidity: 0-1 (very smooth surface)
assert(pred_data, within_bounds(0,1), solidity,
       description = "Values must be within 0-1 range.")

# Transparency: 0 (least transparent)-1 (most transparent)
assert(pred_data, within_bounds(0,1), transparency,
       description = "Values must be within 0-1 range.")

# T/W Ratio: 0-1 (represents a sphere)
assert(pred_data, within_bounds(0,1), t_w_ratio,
       description = "Values must be within 0-1 range.")

# Sphericity: 0-1 (perfect circle)
assert(pred_data, within_bounds(0,1), sphericity,
       description = "Values must be within 0-1 range.")

# Concavity: 0-1 (rough, spikey surface)
assert(pred_data, within_bounds(0,1), concavity,
       description = "Values must be within 0-1 range.")

# Convexity: 0-1 (smooth)
assert(pred_data, within_bounds(0,1), convexity,
       description = "Values must be within 0-1 range.")

#L/W Aspect Ratio: 1 (sphere)-infinity
assert(pred_data, within_bounds(1,Inf), l_w_ratio,
       description = "Values must be within 1-infinity range.")

# W/T Ratio: 1 (sphere)-infinity
assert(pred_data, within_bounds(1,Inf), w_t_ratio,
       description = "Values must be within 1-infinity range.")

# Verify that f_width always is between 0.125-6 range
assert(pred_data, within_bounds(0.125,6), f_width,
       description = "Values must be within 0.125-6 range." )


}

```

# Predict using all loading models

```{r predict on the data using the provided models}

predict_with_models <- function (model_workflow, model_best_params, test_data) {
  
  #finalize workflow with model hyperparameters
  model_final_wf <- model_workflow %>%
    finalize_workflow(model_best_params)
  model_final_wf

  #using final workflow, fit on test data
  final_fit <- model_final_wf %>%
    fit(data = test_data)

  #create the training prediction data frames
  model_training_preds <- get_prediction_dataframes(final_fit, test_data)


  assert(model_training_preds, within_bounds(0,1), .pred_site, 
       description = "Predicition probabilities must be between 0 and 1")
  assert(model_training_preds, within_bounds(0,1), .pred_exp, 
       description = "Predicition probabilities must be between 0 and 1")
  
  
  assert(model_training_preds, (in_set(c("exp", "site") ) ), .pred_class, 
       description = "Predicition must be experimental or site")
    assert(model_training_preds, (in_set(c("exp", "site") ) ), particle_class, 
       description = "Predicition must be experimental or site")
    
    return(model_training_preds)

}
```

#Identify particles which require review 

```{r identify mismatched particles}
combine_prediction_frames <-function (glmnet_pred_frame, xbg_pred_frame, rf_pred_frame) {
  
  combined_pred_frame <- data.frame(id = seq.int(nrow(glmnet_pred_frame)),
                                  glm = glmnet_pred_frame$.pred_class,
                                  xgb = xgb_pred_frame$.pred_class,
                                  rf = rf_pred_frame$.pred_class
                        )

  return (combined_pred_frame)
}

review_particles_mismatch <-function (combined_pred_frame) {
  
combined_pred_frame$count.exp <- apply(combined_pred_frame[2:4], 1, function(x) length(which(x=="exp")))

mismatched_particles <- combined_pred_frame %>%
    filter(count.exp == 2 | count.exp == 1)


mismatched_particles$majority <- ifelse(mismatched_particles$count.exp==2, "exp", "site")




  return(mismatched_particles)
  
}

```


```{r identify particles of concern}
review_particles_questionable <-function (pred_frame) {
  
  ##model was unsure about a particle's class
  questionable_particles <- pred_frame %>%
    filter(.pred_exp >= 0.49 & .pred_exp <= 0.51 ) %>%
    filter(.pred_site >= 0.49 & .pred_site <= 0.51 )
  
  return(questionable_particles)
  
}


```


#Output the percentage of microdebitage estimated in the sample

```{r percentage microdebitage function}


percent_microdebitage <- function(pred_frame) {
  
 microdeb_count <- sum(pred_frame$.pred_class == "exp") 
    
 totalpart_count <- sum(pred_frame$.pred_class == "exp" ) + sum(pred_frame$.pred_class == "site" )

  return( (100*(microdeb_count / totalpart_count)) )
}

```

